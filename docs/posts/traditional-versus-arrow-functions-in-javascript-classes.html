<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Traditional versus Arrow functions in JavaScript Classes by Suhan Wijaya</title><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="title" content="Traditional versus Arrow functions in JavaScript Classes by Suhan Wijaya"/><meta name="description"/><meta property="og:type" content="website"/><meta property="og:url" content="https://www.suhanwijaya.com/posts/traditional-versus-arrow-functions-in-javascript-classes"/><meta property="og:title" content="Traditional versus Arrow functions in JavaScript Classes by Suhan Wijaya"/><meta property="og:description"/><meta property="og:image"/><meta name="twitter:title" content="Traditional versus Arrow functions in JavaScript Classes by Suhan Wijaya"/><meta name="twitter:description"/><meta name="twitter:image"/><meta name="twitter:card" content="summary_large_image"/><link rel="canonical" href="https://medium.com/javascript-in-plain-english/traditional-versus-arrow-functions-in-javascript-classes-35f958b1a492"/><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/styles.a9a638f4.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.a9a638f4.chunk.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-08372472a9a690b518ed.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-147ea3ada7109f6dc0bb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/e4c8223e6318a62675b83f1688c61c375db5b2bb.d4f57090bd55662b89aa.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.557bf609d0b75d1fc8e4.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3f426cc9284b0d3f87e0.js" as="script"/><link rel="preload" href="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.4aea04fc80fc95b214df.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-1cc17da55ef19e625b6d.js" as="script"/></head><body><div id="__next"><div class="layout_GvkLX hasTopMenu_1WVP3"><nav class="menu_2G6rj topMenu_3pGJ_"><h2 class="name_10dbC">suhan <br/>wijaya</h2><ul class="menuItems_26ie3"><li class="menuItem_5m-L2"><a href="/#intro">INTRO</a></li><li class="menuItem_5m-L2"><a href="/#about">ABOUT</a></li><li class="menuItem_5m-L2"><a href="/#blog">BLOG</a></li><li class="menuItem_5m-L2"><a href="/#projects">PROJECTS</a></li><li class="menuItem_5m-L2"><a href="/#contact">CONTACT</a></li><li class="menuItem_5m-L2"><a href="/#technologies">TECHNOLOGIES</a></li></ul><a href="mailto:suhanw@gmail.com" target="_blank" class="email_3kN3h">suhanw@gmail.com</a><div class="social_3_hb2"><a href="https://www.linkedin.com/in/suhanwijaya/" target="_blank"><img src="/images/linked-in.png"/></a><a href="https://twitter.com/suhanw" target="_blank"><img src="/images/twitter.png"/></a><a href="https://github.com/suhanw" target="_blank"><img src="/images/github.png"/></a></div><ul class="topMenuItems_3Vx-y"><li class="menuItem_5m-L2"><a href="/#blog">BACK TO HOME</a></li></ul></nav><button class="hamburger_1KX_H"><img src="/images/hamburger.png"/></button><article class="contentWrapper_1Wy1l"><h1 class="title_29RlI">Traditional versus Arrow functions in JavaScript Classes</h1><div class="description_1Da_c"></div><div class="date_2avFh"><time dateTime="2020-11-04">Nov 4, 2020</time></div><div class="content_33yU5"><p><img src="https://miro.medium.com/max/1280/1*-IeFjTYIltNhNfNW4hE5YA.jpeg" alt="The two states of every programmer">
<em>Source: <a href="https://programmerhumour.tumblr.com/image/633387776634732544">Programmer Humor</a></em></p>
<hr>
<p>This is a spiritual sequel to <a href="https://medium.com/the-innovation/a-method-destructured-from-an-object-loses-its-original-context-21e73cf1451f">this article</a>.</p>
<p>Create a class with a method using Traditional function like so. Let‚Äôs call this <strong>Approach A</strong>.</p>
<pre><code class="language-javascript">// APPROACH A

class SomeClass {
    constructor() {
        this.someProp = 'someValue';
    }

    someMethod() { // Traditional function
        console.log(this.someProp);
    }
}
</code></pre>
<p>Create an instance of that class. When invoking the method on the instance, <code>this</code> refers to the instance. So far, it‚Äôs behaving as expected.</p>
<pre><code class="language-javascript">let instance = new SomeClass();

instance.someMethod(); // logs 'someValue'
</code></pre>
<p>But, as soon as we assign the method to a variable and call that function variable, the method loses its context, and you get <code>Uncaught TypeError: Cannot read property ‚ÄòsomeProp‚Äô of undefined</code>.</p>
<pre><code class="language-javascript">let instance = new SomeClass();

let funcVariable = instance.someMethod;
funcVariable(); // logs error
</code></pre>
<p>OK.</p>
<p>Now, let‚Äôs create the class with a method using Arrow function like so. Let‚Äôs call this <strong>Approach B</strong>.</p>
<pre><code class="language-javascript">// APPROACH B

class SomeClass {
    constructor() {
        this.someProp = 'someValue';
    }

    someMethod = () => { // Arrow function
        console.log(this.someProp);
    }
}
</code></pre>
<p>This now works.</p>
<pre><code class="language-javascript">let instance = new SomeClass();

let funcVariable = instance.someMethod;
funcVariable(); // logs 'someValue'

const { someMethod } = instance; // destructuring also works!
someMethod(); // logs 'someValue'
</code></pre>
<hr>
<p>##Why, JavaScript, why?##</p>
<p>As per <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN docs</a>, ‚Äúthe class keyword is introduced in ES2015, but is syntactical sugar, JavaScript remains prototype-based.‚Äù So if we were to write in pre-ES6 syntax, <strong>Approach A</strong> looks like this.</p>
<pre><code class="language-javascript">// Equivalent to APPROACH A

'use strict';

var SomeClass = function() {
    this.someProp = 'someValue';
}

SomeClass.prototype.someMethod = function() {
    console.log(this.someProp);
}

var instance = new SomeClass();
</code></pre>
<p>The property <code>someMethod</code> is defined on the constructor function‚Äôs <code>prototype</code>.
<img src="https://miro.medium.com/max/1036/1*dCPPZGSH9Qf_c7RdTFa2Ag.png" alt="Chrome Dev Console"></p>
<hr>
<p>But not on the <code>instance</code>.
<img src="https://miro.medium.com/max/1072/1*I9XIUW-edxdWn_Y8I-8qRQ.png" alt="Chrome Dev Console"></p>
<hr>
<p>You can access <code>instance.someMethod</code> through <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">prototypal inheritance</a>.</p>
<p><strong>But when you assign <code>instance.someMethod</code> to another variable, the function variable loses its context.</strong></p>
<p>Further, since <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions">‚Äúcode within the <code>class</code> body's syntactic boundary is always executed in strict mode‚Äù</a>, <code>this</code> will be undefined instead of defaulting to <code>window</code> or <code>global</code>.</p>
<p>OK.</p>
<p>Now, <strong>Approach B</strong> looks like this in pre-ES6:</p>
<pre><code class="language-javascript">// Equivalent to APPROACH B

'use strict';

var SomeClass = function() {
    this.someProp = 'someValue';

    var _that = this;

    this.someMethod = function() {
        console.log(_that.someProp);
    }
}

var instance = new SomeClass();
</code></pre>
<p>The property <code>someMethod</code> is not defined on the constructor function‚Äôs <code>prototype</code>.
<img src="https://miro.medium.com/max/648/1*Axs8fo1y575ZiMwsy5P02Q.png" alt="Chrome Dev Console"></p>
<hr>
<p>Instead, it is defined on the <code>instance</code>.
<img src="https://miro.medium.com/max/1420/1*yUkx782Yo1M1fBe8np9mDg.png" alt="Chrome Dev Console"></p>
<hr>
<p>Further, an Arrow function is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Description">bound to its surrounding lexical context by default</a> (where it physically sits in the code), which seems equivalent to a Traditional function having access to an outer function variable that points to <code>this</code> (i.e., <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">closure</a>).</p>
<p><strong>Hence, even when you assign <code>instance.someMethod</code> to another variable, the function variable remains bound to the instance context.</strong></p>
<p>Note: I‚Äôm not 100% sure about the actual ‚Äòunder the hood‚Äô mechanism by which Arrow functions derive <code>this</code>, so feel free to comment if you do know.</p>
<p>In any case, I went down this rabbit hole because I‚Äôve been using Arrow functions for writing methods in classical React components, instead of binding Traditional functions (i.e., <code>this.someMethod.bind(this)</code>) in the <code>constructor</code> or when passing it down as prop.</p>
<pre><code class="language-javascript">import React from 'react';

class SomeComponent extends React.Component {
    constructor(props) {
        super(props);

        this.state = { /* some state */ };
    }

    someMethod = () => { // Arrow function
        // will have access to `this.state`
    }

    render() {
        // may attach `this.someMethod` as an event handler or 
        // pass it down as a prop to child components
    }
}
</code></pre>
<p>Not endorsing one approach or the other, just describing the difference. Oh, and guess <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Browser_compatibility">which browser</a> is completely irrelevant to this whole discussion.</p>
<hr>
<p>üì´ <em>Hit me up on <a href="https://www.linkedin.com/in/suhanwijaya/">LinkedIn</a> or <a href="https://twitter.com/suhanw">Twitter</a>!</em></p>
</div><div class="footer_2PjJq"></div></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"traditional-versus-arrow-functions-in-javascript-classes","contentHtml":"\u003cp\u003e\u003cimg src=\"https://miro.medium.com/max/1280/1*-IeFjTYIltNhNfNW4hE5YA.jpeg\" alt=\"The two states of every programmer\"\u003e\n\u003cem\u003eSource: \u003ca href=\"https://programmerhumour.tumblr.com/image/633387776634732544\"\u003eProgrammer Humor\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eThis is a spiritual sequel to \u003ca href=\"https://medium.com/the-innovation/a-method-destructured-from-an-object-loses-its-original-context-21e73cf1451f\"\u003ethis article\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCreate a class with a method using Traditional function like so. Let‚Äôs call this \u003cstrong\u003eApproach A\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// APPROACH A\n\nclass SomeClass {\n    constructor() {\n        this.someProp = 'someValue';\n    }\n\n    someMethod() { // Traditional function\n        console.log(this.someProp);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCreate an instance of that class. When invoking the method on the instance, \u003ccode\u003ethis\u003c/code\u003e refers to the instance. So far, it‚Äôs behaving as expected.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elet instance = new SomeClass();\n\ninstance.someMethod(); // logs 'someValue'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut, as soon as we assign the method to a variable and call that function variable, the method loses its context, and you get \u003ccode\u003eUncaught TypeError: Cannot read property ‚ÄòsomeProp‚Äô of undefined\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elet instance = new SomeClass();\n\nlet funcVariable = instance.someMethod;\nfuncVariable(); // logs error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOK.\u003c/p\u003e\n\u003cp\u003eNow, let‚Äôs create the class with a method using Arrow function like so. Let‚Äôs call this \u003cstrong\u003eApproach B\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// APPROACH B\n\nclass SomeClass {\n    constructor() {\n        this.someProp = 'someValue';\n    }\n\n    someMethod = () =\u003e { // Arrow function\n        console.log(this.someProp);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis now works.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003elet instance = new SomeClass();\n\nlet funcVariable = instance.someMethod;\nfuncVariable(); // logs 'someValue'\n\nconst { someMethod } = instance; // destructuring also works!\nsomeMethod(); // logs 'someValue'\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e##Why, JavaScript, why?##\u003c/p\u003e\n\u003cp\u003eAs per \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\"\u003eMDN docs\u003c/a\u003e, ‚Äúthe class keyword is introduced in ES2015, but is syntactical sugar, JavaScript remains prototype-based.‚Äù So if we were to write in pre-ES6 syntax, \u003cstrong\u003eApproach A\u003c/strong\u003e looks like this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Equivalent to APPROACH A\n\n'use strict';\n\nvar SomeClass = function() {\n    this.someProp = 'someValue';\n}\n\nSomeClass.prototype.someMethod = function() {\n    console.log(this.someProp);\n}\n\nvar instance = new SomeClass();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe property \u003ccode\u003esomeMethod\u003c/code\u003e is defined on the constructor function‚Äôs \u003ccode\u003eprototype\u003c/code\u003e.\n\u003cimg src=\"https://miro.medium.com/max/1036/1*dCPPZGSH9Qf_c7RdTFa2Ag.png\" alt=\"Chrome Dev Console\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eBut not on the \u003ccode\u003einstance\u003c/code\u003e.\n\u003cimg src=\"https://miro.medium.com/max/1072/1*I9XIUW-edxdWn_Y8I-8qRQ.png\" alt=\"Chrome Dev Console\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eYou can access \u003ccode\u003einstance.someMethod\u003c/code\u003e through \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\"\u003eprototypal inheritance\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBut when you assign \u003ccode\u003einstance.someMethod\u003c/code\u003e to another variable, the function variable loses its context.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eFurther, since \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions\"\u003e‚Äúcode within the \u003ccode\u003eclass\u003c/code\u003e body's syntactic boundary is always executed in strict mode‚Äù\u003c/a\u003e, \u003ccode\u003ethis\u003c/code\u003e will be undefined instead of defaulting to \u003ccode\u003ewindow\u003c/code\u003e or \u003ccode\u003eglobal\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOK.\u003c/p\u003e\n\u003cp\u003eNow, \u003cstrong\u003eApproach B\u003c/strong\u003e looks like this in pre-ES6:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// Equivalent to APPROACH B\n\n'use strict';\n\nvar SomeClass = function() {\n    this.someProp = 'someValue';\n\n    var _that = this;\n\n    this.someMethod = function() {\n        console.log(_that.someProp);\n    }\n}\n\nvar instance = new SomeClass();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe property \u003ccode\u003esomeMethod\u003c/code\u003e is not defined on the constructor function‚Äôs \u003ccode\u003eprototype\u003c/code\u003e.\n\u003cimg src=\"https://miro.medium.com/max/648/1*Axs8fo1y575ZiMwsy5P02Q.png\" alt=\"Chrome Dev Console\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eInstead, it is defined on the \u003ccode\u003einstance\u003c/code\u003e.\n\u003cimg src=\"https://miro.medium.com/max/1420/1*yUkx782Yo1M1fBe8np9mDg.png\" alt=\"Chrome Dev Console\"\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eFurther, an Arrow function is \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Description\"\u003ebound to its surrounding lexical context by default\u003c/a\u003e (where it physically sits in the code), which seems equivalent to a Traditional function having access to an outer function variable that points to \u003ccode\u003ethis\u003c/code\u003e (i.e., \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\"\u003eclosure\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHence, even when you assign \u003ccode\u003einstance.someMethod\u003c/code\u003e to another variable, the function variable remains bound to the instance context.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNote: I‚Äôm not 100% sure about the actual ‚Äòunder the hood‚Äô mechanism by which Arrow functions derive \u003ccode\u003ethis\u003c/code\u003e, so feel free to comment if you do know.\u003c/p\u003e\n\u003cp\u003eIn any case, I went down this rabbit hole because I‚Äôve been using Arrow functions for writing methods in classical React components, instead of binding Traditional functions (i.e., \u003ccode\u003ethis.someMethod.bind(this)\u003c/code\u003e) in the \u003ccode\u003econstructor\u003c/code\u003e or when passing it down as prop.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003eimport React from 'react';\n\nclass SomeComponent extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = { /* some state */ };\n    }\n\n    someMethod = () =\u003e { // Arrow function\n        // will have access to `this.state`\n    }\n\n    render() {\n        // may attach `this.someMethod` as an event handler or \n        // pass it down as a prop to child components\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot endorsing one approach or the other, just describing the difference. Oh, and guess \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Browser_compatibility\"\u003ewhich browser\u003c/a\u003e is completely irrelevant to this whole discussion.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003eüì´ \u003cem\u003eHit me up on \u003ca href=\"https://www.linkedin.com/in/suhanwijaya/\"\u003eLinkedIn\u003c/a\u003e or \u003ca href=\"https://twitter.com/suhanw\"\u003eTwitter\u003c/a\u003e!\u003c/em\u003e\u003c/p\u003e\n","title":"Traditional versus Arrow functions in JavaScript Classes","date":"2020-11-04","tags":"javascript,coding,webdev,react","canonical_url":"https://medium.com/javascript-in-plain-english/traditional-versus-arrow-functions-in-javascript-classes-35f958b1a492"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"traditional-versus-arrow-functions-in-javascript-classes"},"buildId":"oUwCYgRAiP4J1kn0PO9aK","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-28a453ab78bd7ac4fdb9.js"></script><script src="/_next/static/chunks/main-08372472a9a690b518ed.js" async=""></script><script src="/_next/static/chunks/webpack-147ea3ada7109f6dc0bb.js" async=""></script><script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script><script src="/_next/static/chunks/e4c8223e6318a62675b83f1688c61c375db5b2bb.d4f57090bd55662b89aa.js" async=""></script><script src="/_next/static/chunks/styles.557bf609d0b75d1fc8e4.js" async=""></script><script src="/_next/static/chunks/pages/_app-3f426cc9284b0d3f87e0.js" async=""></script><script src="/_next/static/chunks/7989c093b81d86ddb0abfb342d5bc2e84730435d.4aea04fc80fc95b214df.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-1cc17da55ef19e625b6d.js" async=""></script><script src="/_next/static/oUwCYgRAiP4J1kn0PO9aK/_buildManifest.js" async=""></script><script src="/_next/static/oUwCYgRAiP4J1kn0PO9aK/_ssgManifest.js" async=""></script></body></html>