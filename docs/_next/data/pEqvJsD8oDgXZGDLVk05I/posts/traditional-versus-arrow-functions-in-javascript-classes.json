{"pageProps":{"postData":{"id":"traditional-versus-arrow-functions-in-javascript-classes","contentHtml":"<p><img src=\"https://miro.medium.com/max/1280/1*-IeFjTYIltNhNfNW4hE5YA.jpeg\" alt=\"The two states of every programmer\">\n<em>Source: <a href=\"https://programmerhumour.tumblr.com/image/633387776634732544\">Programmer Humor</a></em></p>\n<hr>\n<p>This is a spiritual sequel to <a href=\"https://medium.com/the-innovation/a-method-destructured-from-an-object-loses-its-original-context-21e73cf1451f\">this article</a>.</p>\n<p>Create a class with a method using Traditional function like so. Let‚Äôs call this <strong>Approach A</strong>.</p>\n<pre><code class=\"language-javascript\">// APPROACH A\n\nclass SomeClass {\n    constructor() {\n        this.someProp = 'someValue';\n    }\n\n    someMethod() { // Traditional function\n        console.log(this.someProp);\n    }\n}\n</code></pre>\n<p>Create an instance of that class. When invoking the method on the instance, <code>this</code> refers to the instance. So far, it‚Äôs behaving as expected.</p>\n<pre><code class=\"language-javascript\">let instance = new SomeClass();\n\ninstance.someMethod(); // logs 'someValue'\n</code></pre>\n<p>But, as soon as we assign the method to a variable and call that function variable, the method loses its context, and you get <code>Uncaught TypeError: Cannot read property ‚ÄòsomeProp‚Äô of undefined</code>.</p>\n<pre><code class=\"language-javascript\">let instance = new SomeClass();\n\nlet funcVariable = instance.someMethod;\nfuncVariable(); // logs error\n</code></pre>\n<p>OK.</p>\n<p>Now, let‚Äôs create the class with a method using Arrow function like so. Let‚Äôs call this <strong>Approach B</strong>.</p>\n<pre><code class=\"language-javascript\">// APPROACH B\n\nclass SomeClass {\n    constructor() {\n        this.someProp = 'someValue';\n    }\n\n    someMethod = () => { // Arrow function\n        console.log(this.someProp);\n    }\n}\n</code></pre>\n<p>This now works.</p>\n<pre><code class=\"language-javascript\">let instance = new SomeClass();\n\nlet funcVariable = instance.someMethod;\nfuncVariable(); // logs 'someValue'\n\nconst { someMethod } = instance; // destructuring also works!\nsomeMethod(); // logs 'someValue'\n</code></pre>\n<hr>\n<p>##Why, JavaScript, why?##</p>\n<p>As per <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">MDN docs</a>, ‚Äúthe class keyword is introduced in ES2015, but is syntactical sugar, JavaScript remains prototype-based.‚Äù So if we were to write in pre-ES6 syntax, <strong>Approach A</strong> looks like this.</p>\n<pre><code class=\"language-javascript\">// Equivalent to APPROACH A\n\n'use strict';\n\nvar SomeClass = function() {\n    this.someProp = 'someValue';\n}\n\nSomeClass.prototype.someMethod = function() {\n    console.log(this.someProp);\n}\n\nvar instance = new SomeClass();\n</code></pre>\n<p>The property <code>someMethod</code> is defined on the constructor function‚Äôs <code>prototype</code>.\n<img src=\"https://miro.medium.com/max/1036/1*dCPPZGSH9Qf_c7RdTFa2Ag.png\" alt=\"Chrome Dev Console\"></p>\n<hr>\n<p>But not on the <code>instance</code>.\n<img src=\"https://miro.medium.com/max/1072/1*I9XIUW-edxdWn_Y8I-8qRQ.png\" alt=\"Chrome Dev Console\"></p>\n<hr>\n<p>You can access <code>instance.someMethod</code> through <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\">prototypal inheritance</a>.</p>\n<p><strong>But when you assign <code>instance.someMethod</code> to another variable, the function variable loses its context.</strong></p>\n<p>Further, since <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions\">‚Äúcode within the <code>class</code> body's syntactic boundary is always executed in strict mode‚Äù</a>, <code>this</code> will be undefined instead of defaulting to <code>window</code> or <code>global</code>.</p>\n<p>OK.</p>\n<p>Now, <strong>Approach B</strong> looks like this in pre-ES6:</p>\n<pre><code class=\"language-javascript\">// Equivalent to APPROACH B\n\n'use strict';\n\nvar SomeClass = function() {\n    this.someProp = 'someValue';\n\n    var _that = this;\n\n    this.someMethod = function() {\n        console.log(_that.someProp);\n    }\n}\n\nvar instance = new SomeClass();\n</code></pre>\n<p>The property <code>someMethod</code> is not defined on the constructor function‚Äôs <code>prototype</code>.\n<img src=\"https://miro.medium.com/max/648/1*Axs8fo1y575ZiMwsy5P02Q.png\" alt=\"Chrome Dev Console\"></p>\n<hr>\n<p>Instead, it is defined on the <code>instance</code>.\n<img src=\"https://miro.medium.com/max/1420/1*yUkx782Yo1M1fBe8np9mDg.png\" alt=\"Chrome Dev Console\"></p>\n<hr>\n<p>Further, an Arrow function is <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#Description\">bound to its surrounding lexical context by default</a> (where it physically sits in the code), which seems equivalent to a Traditional function having access to an outer function variable that points to <code>this</code> (i.e., <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\">closure</a>).</p>\n<p><strong>Hence, even when you assign <code>instance.someMethod</code> to another variable, the function variable remains bound to the instance context.</strong></p>\n<p>Note: I‚Äôm not 100% sure about the actual ‚Äòunder the hood‚Äô mechanism by which Arrow functions derive <code>this</code>, so feel free to comment if you do know.</p>\n<p>In any case, I went down this rabbit hole because I‚Äôve been using Arrow functions for writing methods in classical React components, instead of binding Traditional functions (i.e., <code>this.someMethod.bind(this)</code>) in the <code>constructor</code> or when passing it down as prop.</p>\n<pre><code class=\"language-javascript\">import React from 'react';\n\nclass SomeComponent extends React.Component {\n    constructor(props) {\n        super(props);\n\n        this.state = { /* some state */ };\n    }\n\n    someMethod = () => { // Arrow function\n        // will have access to `this.state`\n    }\n\n    render() {\n        // may attach `this.someMethod` as an event handler or \n        // pass it down as a prop to child components\n    }\n}\n</code></pre>\n<p>Not endorsing one approach or the other, just describing the difference. Oh, and guess <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Browser_compatibility\">which browser</a> is completely irrelevant to this whole discussion.</p>\n<hr>\n<p>üì´ <em>Hit me up on <a href=\"https://www.linkedin.com/in/suhanwijaya/\">LinkedIn</a> or <a href=\"https://twitter.com/suhanw\">Twitter</a>!</em></p>\n","title":"Traditional versus Arrow functions in JavaScript Classes","date":"2020-11-04","tags":"javascript,coding,webdev,react","canonical_url":"https://medium.com/javascript-in-plain-english/traditional-versus-arrow-functions-in-javascript-classes-35f958b1a492"}},"__N_SSG":true}