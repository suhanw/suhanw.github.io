{"pageProps":{"postData":{"id":"designing-white-label-web-app","contentHtml":"<figure>\n    <img src=\"/images/designing-white-label-web-app-cover.jpg\">\n</figure>\n<hr>\n<p>A big challenge we had to tackle recently was to scale up our existing e-commerce web application which has been designed for a single retailer brand, to deploy multiple storefronts for various retailers that sign up for our ‚Äúwhite label‚Äù service.</p>\n<p>In addition, our solution needs to account for several requirements and constraints:</p>\n<ul>\n<li>avoid major rewrites and maintain code reusability</li>\n<li>address internationalization and localization specific to each retailer</li>\n<li>address theming and branding specific to each retailer</li>\n<li>allow for various degrees of customization and extensibility of features</li>\n<li>a deployment strategy that scales with the number of retailers</li>\n</ul>\n<hr>\n<h3>Monorepo Structure</h3>\n<figure>\n    <img src=\"/images/designing-white-label-web-app-monorepo-structure.png\">\n</figure>\n<p>A monorepo structure refers to a single repository that houses multiple applications. In our case, each retailer has its own application (<code class=\"language-unknown\">app</code>), that consumes either retailer-specific libraries (<code class=\"language-unknown\">lib</code>), or shared libraries that are reusable across retailers.</p>\n<ol>\n<li>One <code class=\"language-unknown\">app</code> per retailer:\n<ul>\n<li>Each retailer has its own dedicated app within the monorepo.</li>\n<li>The retailer app does not contain any components, services, or business logic. It instead configures dependency injection and wires up libs, based on retailer-specific configs.</li>\n<li>Retailer-specific environment variables and configs are managed within the respective app, ensuring a tailored experience for each retailer.</li>\n</ul>\n</li>\n<li>One retailer-specific <code class=\"language-unknown\">lib</code> per retailer:\n<ul>\n<li>Code that is unique to each retailer lives in this <code class=\"language-unknown\">lib</code>, comprising approximately 10-20% of the overall code.</li>\n<li>Examples of retailer-specific code include internationalization/localization content, branding color schemes and typography, and any business logic particular to the retailer.</li>\n<li>These retailer-specific libraries must adhere to a common interface, enabling easy integration into shared libraries and components.</li>\n</ul>\n</li>\n<li>Multiple shared <code class=\"language-unknown\">lib</code>s reusable across retailers:\n<ul>\n<li>Shared libraries constitute the majority of the codebase, accounting for approximately 80-90% of the overall code.</li>\n<li>These shared libraries contain reusable code that can be utilized by all retailers, ensuring consistency and promoting code reusability.</li>\n<li>By default, new features are implemented within shared libraries to enable seamless inheritance across retailers.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>Broad Strategy</h3>\n<figure>\n    <img src=\"https://media.tenor.com/HnurQKt7zSQAAAAC/jim-carrey-jim-carrey-typing.gif\">\n</figure>\n<p>To efficiently manage code within the monorepo structure, here‚Äôs the general strategy that governs where features are implemented and how the code is organized.</p>\n<ol>\n<li>Shared libraries for common features:\n<ul>\n<li>Unless explicitly specified, new features are implemented within shared libraries, allowing all retailers, including future retailers, to inherit these features by default.</li>\n<li>This approach ensures consistency across all retailers and simplifies maintaining feature parity.</li>\n</ul>\n</li>\n<li>Retailer-specific libraries for unique features:\n<ul>\n<li>If there is a clear distinction in business logic between retailers, or a feature is particular to a retailer, it is implemented within retailer-specific libraries.</li>\n<li>Retailer-specific libraries follow the same interface requirements, enabling seamless integration with shared libraries and components.</li>\n<li>For instance, each retailer must have a <code class=\"language-unknown\">Logo</code> component. The shared <code class=\"language-unknown\">TopNav</code> component imports the appropriate <code class=\"language-unknown\">Logo</code> component based on the compile configurations defined in the retailer app.</li>\n</ul>\n</li>\n<li>Flexibility in code organization:\n<ul>\n<li>Depending on the complexity of retailer-specific logic, code organization within retailer-specific libraries can be high-level or low-level.</li>\n<li>For example, we can create a distinct <code class=\"language-unknown\">TopNav</code> component for each retailer to display a retailer-specific logo.</li>\n<li>Alternatively, all retailers can use a shared <code class=\"language-unknown\">TopNav</code> component that has common UI features, while importing a retailer-specific <code class=\"language-unknown\">Logo</code> component.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>Deployment Mechanism</h3>\n<figure>\n    <img src=\"/images/designing-white-label-web-app-deploy-chart.png\">\n</figure>\n<p>Efficient deployment is crucial to propagate updates correctly across retailers and to avoid unnecessary deployments. The logic is essentially this:</p>\n<ol>\n<li>Perform code change analysis between the most recent commit and the last commit that triggered a successful production deployment.</li>\n<li>If updates were made only to retailer-specific code, only deploy that particular retailer storefront.</li>\n<li>If updates were made to code that‚Äôs shared across all or some retailers, only deploy the retailer storefronts with changed dependencies.</li>\n<li>Rinse and repeat.</li>\n</ol>\n<p>Thanks for reading. I may dive into the code in a future(ish üòÖ) article.</p>\n","pin_order":1,"title":"Designing a ‚Äúwhite-label‚Äù e-commerce web app","description":"Streamlining development and deployment with a monorepo","image":"https://www.suhanwijaya.com/images/designing-white-label-web-app-cover.jpg","tags":"javascript,webdev,monorepo,ecommerce","date":"2023-06-03"}},"__N_SSG":true}